package Rasterization;

import java.awt.Color;
import javax.swing.JFrame;
import javax.swing.JComponent;
import java.awt.Graphics;
import java.awt.event.KeyListener;
import java.awt.event.KeyEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseEvent;
import java.util.Arrays;

import java.util.Random;

public class Engine {
    JFrame frame;
    Drawing draw;
    
    int width, height;
    double aspectRatio;
    double zNear,zFar;
    double fov,fovRad,tanFov;
    
    Character camera;
    Vector light, lightViewed;
    
    Matrix4 projectionMat; 
    
    //Object object; 
    Object[] objects=new Object[2]; 
    Vector movement;
    
    boolean UP,DOWN,LEFT,RIGHT;
    boolean[] alphabet=new boolean[26];

    Engine(int width, int height){
        //NDC space setting
        this.width=width;
        this.height=height;
        aspectRatio = (double)this.height/this.width;
        zNear = 1;
        zFar = 1000;
        fov = 90;
        fovRad = fov/180*Math.PI;   
        tanFov = 1.0/Math.tan(fovRad/2);
        
        camera=new Character();
        light=new Vector(0,0,0);
        lightViewed=light.subtract(camera.position);  
        
        //projection matrix
        projectionMat=new Matrix4();
        projectionMat.matrix[0][0] = aspectRatio*tanFov;
        projectionMat.matrix[1][1] = tanFov;
        projectionMat.matrix[2][2] = zFar/(zFar-zNear);
        projectionMat.matrix[3][2] = -zNear*zFar/(zFar-zNear);
        projectionMat.matrix[2][3] = 1;
        
        //object        
        //object=null;    
        movement=new Vector();
        
        //conditions
        UP=false;
        DOWN=false;
        LEFT=false;
        RIGHT=false;
        
        //JFrame
        frame = new JFrame("Testing");
        frame.setSize(width,height);
        frame.setVisible(true);
        frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE);
        draw=new Drawing();
        frame.add(draw); 
        frame.addKeyListener(new KeyboardListener());
        frame.addMouseListener(new MouseButtonListener());
    }
    
    void addObject(Object object){
        for (int i=0;i<objects.length;i++){
            objects[i]=new Object(object);     
            objects[i].initialize(0,0,5*i);
        }
    }
    
    Vector RandomMovement(){
        Random rand = new Random();
        return new Vector((rand.nextInt(3)-1)/10.0,(rand.nextInt(3)-1)/10.0,(rand.nextInt(3)-1)/10.0);
    }
    
    public boolean update(){
        try {
            Thread.sleep(17);
        } catch (InterruptedException ie) {
            ie.printStackTrace();
        }

        /*Random rand = new Random();
        if (rand.nextInt(50)==0)
            movement=RandomMovement();
        object.move(movement);
        */
        moveCharacter(camera);
        //moveObject(object);        
        
        //position light to match camera view
        //lightView=light.subtract(camera.position);            
        //rotate light to match camera view
        //lightView.MatMultiply(camera.orientation.inverse())
        
        draw.repaint();
        return true;
    }
     
    class Drawing extends JComponent{
        public void paint(Graphics g){
            g.setColor(Color.CYAN);
            g.fillRect(0,0,width,height/2);
            g.setColor(Color.GREEN);
            g.fillRect(0,height/2,width,height);
            
            Triangle[] trianglesNDC;
            //iteration
            for (int i=0;i<objects.length-1;i++){ 
                if (objects[i]!=null){
                    drawObject(g, objects[i]);
                }
            }
        } 
    }  
    
    // for drawing a single object
    void drawObject(Graphics g, Object object){       
        Triangle triangle;
        Triangle[] trianglesNDC = new Triangle[object.trigs.length];
        int index=0;
        //Color[] colors={Color.YELLOW,Color.RED,Color.GREEN,Color.BLUE,Color.WHITE};
        for (int i=0;i<object.trigs.length;i++){
            //rotate object from object origin
            triangle=object.trigs[i].rotate(object.orientation); 
            //position object in world space
            triangle.move(object.position.x,object.position.y,object.position.z);            
            
            //position object to match camera view
            triangle.move(-camera.position.x,-camera.position.y,-camera.position.z);            
            //rotate object to match camera view            
            triangle=triangle.rotate(camera.orientation.inverse()); 
            
            //backface culling
            //find normal
            Vector a = triangle.points[1].subtract(triangle.points[0]);
            Vector b = triangle.points[2].subtract(triangle.points[0]);
            Vector normal = a.cross(b);
            normal.normalize();
            //find view to midpoint
            Vector sight = triangle.findMidpoint();
            sight.normalize();
            if (sight.dot(normal)<0) { //if facing camera
                
                //project triangle into NDC space
                triangle=triangle.transform(projectionMat);
                //clip triangles that are completly out of the NDC box
                if(triangle.seen()){
                    //apply clipping to zNear
                    Triangle[] clippedTriangles = clipNear(triangle);
                    for (int j=0;j<2;j++){
                        if (clippedTriangles[j]!=null){
                            triangle=clippedTriangles[j];
                        }else{
                            break;
                        }
                        
                        //perspective division
                        triangle.divide();                    
                        //color triangle based on amount of light shined
                        //double lightShined=-sight.subtract(lightViewed).dot(normal);
                        double lightShined=-sight.dot(normal); //light comes from character
                        //int shade=Math.max(0,(int)(lightShined*255));
                        triangle.darken(1-lightShined);//c=new Color(shade,shade,shade); 
                        //add to list
                        trianglesNDC[index++]=triangle;                
                    }
                }
            }
        }
        
        Triangle[] triangles = new Triangle[index];
        System.arraycopy(trianglesNDC, 0, triangles, 0, index);
        //painter's algorithm
        Arrays.sort(triangles, (a, b) -> Double.compare(
                (b.points[0].z+b.points[1].z+b.points[2].z)/3,
                (a.points[0].z+a.points[1].z+a.points[2].z)/3));
        //draw the triangles
        for(int i=0;i<index;i++){
            drawFillTriangle(g,toScreen(triangles[i]),triangles[i].c); 
        }

    }
    
//---------------functions below move objects---------------\\   
    void moveCharacter(Character c){ 
        // camera movement
        int frontBack=0,leftRight=0,upDown=0;
        if(UP){
            frontBack=1;
        }else if(DOWN){
            frontBack=-1;
        }
        if(RIGHT){
            leftRight=1;
        }else if(LEFT){
            leftRight=-1;
        }  
        /*
        if(alphabet['N'-65]){
            upDown=1;
        }else if(alphabet['M'-65]){
            upDown=-1;
        }
        */
        
        // camera rotation
        int horizontal=0,vertical=0,turn=0;
        if(alphabet['D'-65]){
            horizontal=1;
        }else if(alphabet['A'-65]){
            horizontal=-1;
        }
        if(alphabet['S'-65]){
            vertical=1;
        }else if(alphabet['W'-65]){
            vertical=-1;
        }     
        /*
        if(alphabet['E'-65]){
            turn=-1;
        }else if(alphabet['Q'-65]){
            turn=1;
        }*/
        
        c.rotate(vertical,horizontal,turn);    
        c.applyRotation(); 
        c.move(frontBack,leftRight,upDown);
    }
    
    void moveObject(Object obj){ 
        // object rotation
        int horizontal=0,vertical=0,turn=0;
        if(alphabet['T'-65]){
            vertical=1;
        }else if(alphabet['G'-65]){
            vertical=-1;
        }
        if(alphabet['F'-65]){
            horizontal=1;
        }else if(alphabet['H'-65]){
            horizontal=-1;
        }
        if(alphabet['R'-65]){
            turn=1;
        }else if(alphabet['Y'-65]){
            turn=-1;
        }
        obj.rotate(vertical,horizontal,turn);
    }   
//---------------functions below applies clipping to the triangles---------------\\
    //apply clipping to the near plane
    Triangle[] clipNear(Triangle triangle){
        Triangle[] clippedTriangles=new Triangle[2];
        double near=0.0;
        //if the triangle is completly in front of the near plane
        if(triangle.points[0].z>=near && triangle.points[1].z>=near && triangle.points[2].z>=near){
            clippedTriangles[0]=triangle;
            return clippedTriangles;
        }else{
            //one point out of bound: return two triangles
            if (triangle.points[0].z<near && triangle.points[1].z>=near && triangle.points[2].z>=near){
                clippedTriangles=clip2(triangle.points[0],triangle.points[1],triangle.points[2],near);
            }else if (triangle.points[1].z<near && triangle.points[0].z>=near && triangle.points[2].z>=near){
                clippedTriangles=clip2(triangle.points[1],triangle.points[2],triangle.points[0],near);
            }else if (triangle.points[2].z<near && triangle.points[1].z>=near && triangle.points[0].z>=near){
                clippedTriangles=clip2(triangle.points[2],triangle.points[0],triangle.points[2],near);
            //two points out of bound: return one triangle
            }else if (triangle.points[0].z<near && triangle.points[1].z<near && triangle.points[2].z>=near){
                clippedTriangles[0]=clip1(triangle.points[2],triangle.points[0],triangle.points[2],near);
            }else if (triangle.points[0].z<near && triangle.points[2].z<near && triangle.points[1].z>=near){
                clippedTriangles[0]=clip1(triangle.points[1],triangle.points[2],triangle.points[0],near);
            }else if (triangle.points[2].z<near && triangle.points[1].z<near && triangle.points[0].z>=0){
                clippedTriangles[0]=clip1(triangle.points[0],triangle.points[1],triangle.points[2],near);
            }
            clippedTriangles[0].c=triangle.c;
            if (clippedTriangles[1]!=null)
                clippedTriangles[1].c=triangle.c;
            return clippedTriangles; 
        }        
    }        
    //two points out of bound: return one triangle
    //first point is in range
    Triangle clip1(Vector p1, Vector p2, Vector p3, double z){
        Triangle newTrig=new Triangle();
        newTrig.points[0]=p1;
        double alpha;
        //interpolate for the first point
        alpha=(z-p1.z)/(p2.z-p1.z);      
        newTrig.points[1]=p1.interpolate(p2,alpha);
        //interpolate for the second point
        alpha=(z-p1.z)/(p3.z-p1.z);      
        newTrig.points[2]=p1.interpolate(p3,alpha);
        return newTrig;
    }
    //one point out of bound: return two triangles
    //first point is out of range
    Triangle[] clip2(Vector p1, Vector p2, Vector p3,double z){
        Triangle[] newTrigs=new Triangle[2];
        double alpha;
        //interpolate for the first point
        alpha=(z-p1.z)/(p2.z-p1.z);      
        Vector p12=p1.interpolate(p2,alpha);
        //interpolate for the second point
        alpha=(z-p1.z)/(p3.z-p1.z);      
        Vector p13=p1.interpolate(p3,alpha);
        //create two triangles
        newTrigs[0]=new Triangle(p12,p2,p3);
        newTrigs[1]=new Triangle(p13,p12,p3);
        return newTrigs;
    }   
//---------------functions below should belong to the pixel shader---------------\\
    double[] toScreen(Triangle triangle){
        double[][] points = new double[3][2];
        points[0][0] = (double)width/2  + (triangle.points[0].x*width/2);
        points[0][1] = (double)height/2 - (triangle.points[0].y*height/2);
        points[1][0] = (double)width/2  + (triangle.points[1].x*width/2);
        points[1][1] = (double)height/2 - (triangle.points[1].y*height/2);
        points[2][0] = (double)width/2  + (triangle.points[2].x*width/2);
        points[2][1] = (double)height/2 - (triangle.points[2].y*height/2);
        //sort by y then x
        Arrays.sort(points, (a, b) -> a[1]==b[1]?Double.compare(a[0], b[0]):Double.compare(a[1], b[1]));
        double[] flatten={points[0][0],points[0][1],points[1][0],points[1][1],points[2][0],points[2][1]};
        return flatten;
    }
    //structure
    void drawTriangle(Graphics g, double[] p, Color c){
        g.setColor(c);
        int[] points = new int[6];
        for (int i=0;i<6;i++){
            points[i]=(int)p[i];
        }
        g.drawLine(points[0],points[1],points[2],points[3]);
        g.drawLine(points[0],points[1],points[4],points[5]);
        g.drawLine(points[4],points[5],points[2],points[3]);
    }
    //fill with scanlines
    void drawFillTriangle(Graphics g, double[] points, Color c){     
        if(points[1]==points[3]){ //flat top triangle
            flatTopTriangle(g,points,c);
        }else if(points[3]==points[5]){ //flat bottom triangle
            flatBottomTriangle(g,points,c);
        }else{ //irregular triangle, split
            double middleY=points[3];
            double middleX=(points[4]-points[0])*(points[3]-points[1])/(points[5]-points[1])+points[0];
            if (middleX<points[2]){ //middle on the left
                double[] flatBottom={points[0],points[1],middleX,middleY,points[2],points[3]};
                flatBottomTriangle(g,flatBottom,c);
                double[] flatTop={middleX,middleY,points[2],points[3],points[4],points[5]};
                flatTopTriangle(g,flatTop,c);
            }else{ //middle on the right
                double[] flatBottom={points[0],points[1],points[2],points[3],middleX,middleY};
                flatBottomTriangle(g,flatBottom,c);
                double[] flatTop={points[2],points[3],middleX,middleY,points[4],points[5]};
                flatTopTriangle(g,flatTop,c);
            }
        }
    }   
    //inputs are sorted by y then x
    void flatTopTriangle(Graphics g, double[] points, Color c){
        //xEnd of the first scaneline
        double xEnd=points[2];
        //alpha value of how much xStart changes per y
        double xStartIncrement=(points[4]-points[0])/(points[5]-points[1]);
        //alpha value of how much xEnd changes per y
        double xEndIncrement=(points[4]-points[2])/(points[5]-points[1]);
        drawFlatTriangle(g, c, points, xEnd, xStartIncrement, xEndIncrement);
        //drawTriangle(g,points,Color.WHITE);
    }
    //inputs are sorted by y then x
    void flatBottomTriangle(Graphics g, double[] points, Color c){
        //xEnd of the first scaneline
        double xEnd=points[0];
        //alpha value of how much xStart changes per y
        double xStartIncrement=(points[2]-points[0])/(points[5]-points[1]);
        //alpha value of how much xEnd changes per y
        double xEndIncrement=(points[4]-points[0])/(points[5]-points[1]);
        drawFlatTriangle(g, c, points, xEnd, xStartIncrement, xEndIncrement);
        //drawTriangle(g,points,Color.WHITE);
    }
    //inputs are sorted by y then x
    void drawFlatTriangle(Graphics g,Color c,double[] points,double xE,double xStartIncrement,double xEndIncrement){
        g.setColor(c);
        //clipping on y
        //yStart and yEnd are always the first point and the last point of the triangle
        //apply rasterization rules on which pixel belongs to the triangle
        int yStart=(int)Math.max(0,Math.ceil(points[1]-0.5));
        int yEnd=(int)Math.min(height,Math.ceil(points[5]-0.5));
        //interpolate the first xStart and xEnd value based on yStart
        double xStart=points[0]+(yStart+0.5-points[1])*xStartIncrement;
        double xEnd=xE+(yStart+0.5-points[1])*xEndIncrement;
        for (int y=yStart;y<yEnd;y++,xStart+=xStartIncrement,xEnd+=xEndIncrement){
            //clipping on x
            int xStartPixel=(int)Math.max(0,Math.ceil(xStart-0.5));
            int xEndPixel=(int)Math.min(width,Math.ceil(xEnd-0.5));
            //draw the scanline
            for (int x=xStartPixel;x<xEndPixel;x++)
                g.drawLine(x, y, x, y);
        }
    }
    
    
    class KeyboardListener implements KeyListener{       
        public void keyPressed(KeyEvent e) {          
            int keyCode = e.getKeyCode();
            if(keyCode==KeyEvent.VK_UP) 
                UP=true;
            else if(keyCode==KeyEvent.VK_DOWN) 
                DOWN=true;   
            else if(keyCode==KeyEvent.VK_LEFT) 
                LEFT=true;
            else if(keyCode==KeyEvent.VK_RIGHT) 
                RIGHT=true;
            else if(keyCode>=65 && keyCode<=90){
                alphabet[keyCode-65]=true;
            }
        }
        public void keyReleased(KeyEvent e) {
            int keyCode = e.getKeyCode();
            if(keyCode==KeyEvent.VK_UP) 
                UP=false;
            else if(keyCode==KeyEvent.VK_DOWN) 
                DOWN=false;
            else if(keyCode==KeyEvent.VK_LEFT) 
                LEFT=false;
            else if(keyCode==KeyEvent.VK_RIGHT) 
                RIGHT=false;
            else if(keyCode>=65 && keyCode<=90){
                alphabet[keyCode-65]=false;
            }
        }
        public void keyTyped(KeyEvent e){}
    }
    class MouseButtonListener implements MouseListener{       
        public void mouseClicked(MouseEvent e) {  
        }  
        public void mouseEntered(MouseEvent e) {  
        }  
        public void mouseExited(MouseEvent e) {  
        }  
        public void mousePressed(MouseEvent e) {  
        }  
        public void mouseReleased(MouseEvent e) {  
        }  
    }
}
