package Rasterization;

import java.awt.Color;
import javax.swing.JFrame;
import javax.swing.JComponent;
import java.awt.Graphics;
import java.awt.event.KeyListener;
import java.awt.event.KeyEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseEvent;
import java.util.Arrays;
import java.util.Random;

public class Engine {
    JFrame frame;
    Drawing draw;
    int width, height;

    Character camera;
    Vector3 light, lightViewed;
    Matrix4 projectionMat; 
    Object[] objects;
    Pixel[][] zBuffer;
    
    boolean UP,DOWN,LEFT,RIGHT;
    boolean[] alphabet=new boolean[26];
    
    Engine(int width, int height){      
        this.width=width;
        this.height=height;
        //projection matrix inputs: aspect ratio, field of view, z near, z far
        projectionMat=Matrix4.getProjectionMat((double)height/width,90,1,100);     
        //z-buffer
        zBuffer=new Pixel[width][height];
        //object, camera and light
        objects=new Object[10]; 
        camera=new Character();
        light=new Vector3(0,0,0);
        lightViewed=light.subtract(camera.position);  
        //conditions
        UP=false;
        DOWN=false;
        LEFT=false;
        RIGHT=false; 
        //JFrame
        frame = new JFrame("Testing");
        frame.setSize(width,height);
        frame.setVisible(true);
        frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE);
        draw = new Drawing();
        frame.add(draw); 
        frame.addKeyListener(new KeyboardListener());
        frame.addMouseListener(new MouseButtonListener());
    }
    
    void addObject(Object object){
        for (int i=0;i<objects.length;i++){
            if (objects[i]==null){
                objects[i]=object;
            }     
        }
    }

    void moveCharacter(Character c){ 
        // camera movement
        int frontBack=0,leftRight=0,upDown=0;
        if(UP){
            frontBack=1;
        }else if(DOWN){
            frontBack=-1;
        }
        if(RIGHT){
            leftRight=1;
        }else if(LEFT){
            leftRight=-1;
        }  
        /*
        if(alphabet['N'-65]){
            upDown=1;
        }else if(alphabet['M'-65]){
            upDown=-1;
        }
        */
        
        // camera rotation
        int horizontal=0,vertical=0,turn=0;
        if(alphabet['D'-65]){
            horizontal=1;
        }else if(alphabet['A'-65]){
            horizontal=-1;
        }
        if(alphabet['S'-65]){
            vertical=1;
        }else if(alphabet['W'-65]){
            vertical=-1;
        }     
        /*
        if(alphabet['E'-65]){
            turn=-1;
        }else if(alphabet['Q'-65]){
            turn=1;
        }*/
        
        c.rotate(vertical,horizontal,turn); 
        c.headRotate(vertical,horizontal,turn); 
        c.applyRotation(); 
        c.move(frontBack,leftRight,upDown);
    }
    
    void moveObject(Object obj){ 
        // object rotation
        int horizontal=0,vertical=0,turn=0;
        if(alphabet['T'-65]){
            vertical=1;
        }else if(alphabet['G'-65]){
            vertical=-1;
        }
        if(alphabet['F'-65]){
            horizontal=1;
        }else if(alphabet['H'-65]){
            horizontal=-1;
        }
        if(alphabet['R'-65]){
            turn=1;
        }else if(alphabet['Y'-65]){
            turn=-1;
        }
        obj.rotate(vertical,horizontal,turn);
    }   
    
    public boolean update(){
        try {
            Thread.sleep(17);
        } catch (InterruptedException ie) {
            ie.printStackTrace();
        }

        moveCharacter(camera);
        //moveObject(object[0]);        
        
        //position light to match camera view
        //lightView=light.subtract(camera.position);            
        //rotate light to match camera view
        //lightView.MatMultiply(camera.orientation.inverse())
        
        draw.repaint();
        return true;
    }
     
    class Drawing extends JComponent{
        public void paint(Graphics g){
            //background
            for (int i=0;i<width;i++){
                for (int j=0;j<height;j++){
                    zBuffer[i][j]=new Pixel(Color.WHITE);
                }
            }
            /*
            g.setColor(Color.CYAN);
            g.fillRect(0,0,width,height/3);
            g.setColor(Color.GREEN);
            g.fillRect(0,height/3,width,height);
            */
            
            for (int i=0;i<objects.length;i++){ 
                if (objects[i]!=null){
                    vertexProcessor(objects[i]);
                }
            }
            
            for (int i=0;i<width;i++){
                for (int j=0;j<height;j++){
                    g.setColor(zBuffer[i][j].c);
                    g.drawLine(i,j,i,j);
                }
            }
        } 
    }  
    
    //pipeline
    void vertexProcessor(Object object){
        Object newObj=new Object(object);
        for (int i=0;i<newObj.vertices.length;i++){
            //rotate point from origin
            newObj.vertices[i]=newObj.vertices[i].MatMultiply(newObj.orientation);
            //position point in world space
            newObj.vertices[i]=newObj.vertices[i].add(newObj.position);
            //position point to match camera view
            newObj.vertices[i]=newObj.vertices[i].subtract(camera.position);
            //rotate point to match camera view 
            newObj.vertices[i]=newObj.vertices[i].MatMultiply(camera.headOrientation.inverse());
        }
        triangleAssembler(newObj);
    }
    void triangleAssembler(Object object){
        Triangle triangle;
        for (int i=0;i<object.trigVertices.length;i++){
            Vector3 v1=object.vertices[object.trigVertices[i][0]];
            Vector3 v2=object.vertices[object.trigVertices[i][1]];
            Vector3 v3=object.vertices[object.trigVertices[i][2]];
            if (object.trigTextureVertices!=null){
                Vector2 vt1=object.textureVertices[object.trigTextureVertices[i][0]];
                Vector2 vt2=object.textureVertices[object.trigTextureVertices[i][1]];
                Vector2 vt3=object.textureVertices[object.trigTextureVertices[i][2]];
                triangle=new Triangle(v1,v2,v3,vt1,vt2,vt3);
            }else{
                Color c=object.trigColors[i];
                triangle=new Triangle(v1,v2,v3,c);
            }
            TriangleProcessor(triangle);
        }        
    }
    void TriangleProcessor(Triangle triangle){  
        //backface culling
        //find normal
        Vector3 a = triangle.points[1].subtract(triangle.points[0]);
        Vector3 b = triangle.points[2].subtract(triangle.points[0]);
        Vector3 normal = a.cross(b);
        normal.normalize();
        //find view to midpoint
        Vector3 sight = triangle.findMidpoint();
        sight.normalize();
        if (sight.dot(normal)<0) { //if facing camera
            if(triangle.seen()){
                //color triangle based on amount of light shined
                //double lightShined=-sight.subtract(lightViewed).dot(normal);
                double lightShined=-sight.dot(normal); //light comes from character
                triangle.shade(1-lightShined);//c=new Color(shade,shade,shade); 
                //apply clipping
                clip(triangle);
            }          
        }
    }
    //apply clipping to the near plane
    void clip(Triangle triangle){
        //if the triangle is completly in front of the near plane
        if(triangle.points[0].z>=0 && triangle.points[1].z>=0 && triangle.points[2].z>=0){
            trianglePostProcesser(triangle);
        }else{
            //one point out of bound: return two triangles
            if (triangle.points[0].z<0 && triangle.points[1].z>=0 && triangle.points[2].z>=0){
                clip2(triangle,0,1,2);
            }else if (triangle.points[1].z<0 && triangle.points[0].z>=0 && triangle.points[2].z>=0){
                clip2(triangle,1,2,0);
            }else if (triangle.points[2].z<0 && triangle.points[1].z>=0 && triangle.points[0].z>=0){
                clip2(triangle,2,0,1);
            //two points out of bound: return one triangle
            }else if (triangle.points[0].z<0 && triangle.points[1].z<0 && triangle.points[2].z>=0){
                clip1(triangle,2,0,1);
            }else if (triangle.points[0].z<0 && triangle.points[2].z<0 && triangle.points[1].z>=0){
                clip1(triangle,1,2,0);
            }else if (triangle.points[2].z<0 && triangle.points[1].z<0 && triangle.points[0].z>=0){
                clip1(triangle,0,1,2);
            }
        }        
    }        
    //first point is in range
    void clip1 (Triangle triangle, int pi1, int pi2, int pi3){
        double alpha1=triangle.points[pi1].z/(triangle.points[pi2].z-triangle.points[pi1].z);  
        double alpha2=triangle.points[pi1].z/(triangle.points[pi3].z-triangle.points[pi1].z);    
        triangle.points[pi2]=triangle.points[pi1].interpolate(triangle.points[pi2],alpha1);
        triangle.points[pi3]=triangle.points[pi1].interpolate(triangle.points[pi3],alpha2);
        if (triangle.texturePoints!=null){
            triangle.texturePoints[pi3]=triangle.texturePoints[pi1].interpolate(triangle.texturePoints[pi3],alpha1);
            triangle.texturePoints[pi2]=triangle.texturePoints[pi1].interpolate(triangle.texturePoints[pi2],alpha2);
        }
        trianglePostProcesser(triangle);
    }
    //first point is out of range
    void clip2 (Triangle triangle, int pi1, int pi2, int pi3){
        double alpha1=triangle.points[pi1].z/(triangle.points[pi2].z-triangle.points[pi1].z);  
        double alpha2=triangle.points[pi1].z/(triangle.points[pi3].z-triangle.points[pi1].z);    
        Vector3 p12=triangle.points[pi1].interpolate(triangle.points[pi2],alpha1);
        Vector3 p13=triangle.points[pi1].interpolate(triangle.points[pi3],alpha2);
        Vector2 pt12,pt13;
        if (triangle.texturePoints!=null){
            pt12=triangle.texturePoints[pi1].interpolate(triangle.texturePoints[pi2],alpha2);
            pt13=triangle.texturePoints[pi1].interpolate(triangle.texturePoints[pi3],alpha2);
            trianglePostProcesser(new Triangle(p12,triangle.points[pi2],triangle.points[pi3],
                    pt12,triangle.texturePoints[pi2],triangle.texturePoints[pi3],triangle.c,triangle.shade));
            trianglePostProcesser(new Triangle(p12,triangle.points[pi2],triangle.points[pi3],
                    pt13,pt12,triangle.texturePoints[pi3],triangle.c,triangle.shade));
        }else{
            trianglePostProcesser(new Triangle(p12,triangle.points[pi2],triangle.points[pi3],triangle.c,triangle.shade));
            trianglePostProcesser(new Triangle(p13,p12,triangle.points[pi3],triangle.c,triangle.shade));
        }
    }           
    void trianglePostProcesser(Triangle triangle){
        //perspective division
        triangle.divide();   
        //screen transformation
        for (int i=0;i<3;i++){
            triangle.points[i].x = (double)width/2  + (triangle.points[i].x*width/2);
            triangle.points[i].y = (double)height/2 - (triangle.points[i].y*height/2);
        }
        int pi0=0,pi1=1,pi2=2,temp;
        if (triangle.points[pi1].y<triangle.points[pi0].y){
            temp=pi0;
            pi0=pi1;
            pi1=temp;
        }
        if (triangle.points[pi2].y<triangle.points[pi1].y){
            temp=pi1;
            pi1=pi2;
            pi2=temp;
        }
        if (triangle.points[pi1].y<triangle.points[pi0].y){
            temp=pi0;
            pi0=pi1;
            pi1=temp;
        }
        if(triangle.points[pi0].y==triangle.points[pi1].y){ //flat top triangle
            if (triangle.points[pi1].x<triangle.points[pi0].x){
                temp=pi0;
                pi0=pi1;
                pi1=temp;
            }   
            flatTopTriangle(triangle,pi0,pi1,pi2);
        }else if(triangle.points[pi2].y==triangle.points[pi1].y){ //flat bottom triangle
            if (triangle.points[pi2].x<triangle.points[pi1].x){
                temp=pi1;
                pi1=pi2;
                pi2=temp;
            }   
            flatBottomTriangle(triangle,pi0,pi1,pi2);
        }else{ //irregular triangle, split
            Triangle triangle2;
            if (triangle.texturePoints!=null){
                triangle2=new Triangle(triangle);
            }else{
                triangle2=new Triangle(triangle,triangle.c);
            }
            double alpha=(triangle.points[pi1].y-triangle.points[pi0].y)/(triangle.points[pi2].y-triangle.points[pi0].y);
            Vector3 midP=triangle.points[pi0].interpolate(triangle.points[pi2],alpha);
            if (midP.x<triangle.points[pi1].x){ //middle on the left
                triangle.points[pi2]=midP;
                triangle2.points[pi0]=midP;
                if (triangle.texturePoints!=null){
                    triangle.texturePoints[pi2]=triangle.texturePoints[pi0].interpolate(triangle.texturePoints[pi2],alpha);
                    triangle2.texturePoints[pi0]=triangle.texturePoints[pi0].interpolate(triangle.texturePoints[pi2],alpha);
                }
                flatBottomTriangle(triangle,pi0,pi1,pi2);
                flatTopTriangle(triangle,pi1,pi0,pi2);
            }else{ //middle on the right
                triangle.points[pi2]=midP;
                triangle2.points[pi0]=midP;
                if (triangle.texturePoints!=null){
                    triangle.texturePoints[pi2]=triangle.texturePoints[pi0].interpolate(triangle.texturePoints[pi2],alpha);
                    triangle2.texturePoints[pi0]=triangle.texturePoints[pi0].interpolate(triangle.texturePoints[pi2],alpha);
                }
                flatBottomTriangle(triangle,pi0,pi2,pi1);
                flatTopTriangle(triangle,pi0,pi1,pi2);
            }
        }
    }
    void flatTopTriangle(Triangle triangle, int pi0, int pi1, int pi2){
        //xEnd of the first scaneline
        double xEnd=triangle.points[pi1].x;
        //alpha value of how much xStart changes per y
        double xStartIncrement=(triangle.points[pi2].x-triangle.points[pi0].x)/
                (triangle.points[pi2].y-triangle.points[pi0].y);
        //alpha value of how much xEnd changes per y
        double xEndIncrement=(triangle.points[pi2].x-triangle.points[pi1].x)/
                (triangle.points[pi2].y-triangle.points[pi0].y);
        if (triangle.texturePoints==null){
            drawFlatTriangle(triangle, triangle.c, pi0,pi1,pi2, xEnd, xStartIncrement, xEndIncrement);
        }
    }
    void flatBottomTriangle(Triangle triangle, int pi0, int pi1, int pi2){
        //xEnd of the first scaneline
        double xEnd=triangle.points[pi0].x;
        //alpha value of how much xStart changes per y
        double xStartIncrement=(triangle.points[pi1].x-triangle.points[pi0].x)/
                (triangle.points[pi2].y-triangle.points[pi0].y);
        //alpha value of how much xEnd changes per y
        double xEndIncrement=(triangle.points[pi2].x-triangle.points[pi0].x)/
                (triangle.points[pi2].y-triangle.points[pi0].y);
        if (triangle.texturePoints==null){
            drawFlatTriangle(triangle, triangle.c, pi0,pi1,pi2, xEnd, xStartIncrement, xEndIncrement);
        }
    }
    void drawFlatTriangle(Triangle t,Color c,int pi0, int pi1, int pi2, double xE,double xStartIncrement,double xEndIncrement){
        //clipping on y
        //yStart and yEnd are always the first point and the last point of the triangle
        //apply rasterization rules on which pixel belongs to the triangle
        int yStart=(int)Math.max(0,Math.ceil(t.points[pi0].y-0.5));
        int yEnd=(int)Math.min(height,Math.ceil(t.points[pi2].y-0.5));
        //interpolate the first xStart and xEnd value based on yStart
        double xStart=t.points[pi0].x+(yStart+0.5-t.points[pi0].y)*xStartIncrement;
        double xEnd=xE+(yStart+0.5-t.points[pi0].y)*xEndIncrement;
        for (int y=yStart;y<yEnd;y++,xStart+=xStartIncrement,xEnd+=xEndIncrement){
            //clipping on x
            int xStartPixel=(int)Math.max(0,Math.ceil(xStart-0.5));
            int xEndPixel=(int)Math.min(width,Math.ceil(xEnd-0.5));
            //draw the scanline
            for (int x=xStartPixel;x<xEndPixel;x++)
                putPixel(x,y,0,c);
        }
    }
    void putPixel(int x, int y, double z, Color c){
        zBuffer[x][y]=new Pixel(c,z);
    }
    
    class KeyboardListener implements KeyListener{       
        public void keyPressed(KeyEvent e) {          
            int keyCode = e.getKeyCode();
            if(keyCode==KeyEvent.VK_UP) 
                UP=true;
            else if(keyCode==KeyEvent.VK_DOWN) 
                DOWN=true;   
            else if(keyCode==KeyEvent.VK_LEFT) 
                LEFT=true;
            else if(keyCode==KeyEvent.VK_RIGHT) 
                RIGHT=true;
            else if(keyCode>=65 && keyCode<=90){
                alphabet[keyCode-65]=true;
            }
        }
        public void keyReleased(KeyEvent e) {
            int keyCode = e.getKeyCode();
            if(keyCode==KeyEvent.VK_UP) 
                UP=false;
            else if(keyCode==KeyEvent.VK_DOWN) 
                DOWN=false;
            else if(keyCode==KeyEvent.VK_LEFT) 
                LEFT=false;
            else if(keyCode==KeyEvent.VK_RIGHT) 
                RIGHT=false;
            else if(keyCode>=65 && keyCode<=90){
                alphabet[keyCode-65]=false;
            }
        }
        public void keyTyped(KeyEvent e){}
    }
    class MouseButtonListener implements MouseListener{       
        public void mouseClicked(MouseEvent e) {  
        }  
        public void mouseEntered(MouseEvent e) {  
        }  
        public void mouseExited(MouseEvent e) {  
        }  
        public void mousePressed(MouseEvent e) {  
        }  
        public void mouseReleased(MouseEvent e) {  
        }  
    }
}
